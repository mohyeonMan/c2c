package com.c2c.c2c.e2e;

import com.c2c.c2c.domain.port.out.RoomRepository;
import com.c2c.c2c.domain.port.out.UserRepository;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.web.server.LocalServerPort;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.web.socket.*;
import org.testcontainers.containers.GenericContainer;
import org.testcontainers.containers.PostgreSQLContainer;
import org.testcontainers.junit.jupiter.Container;
import org.testcontainers.junit.jupiter.Testcontainers;
import org.testcontainers.utility.DockerImageName;

import java.net.URI;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;

import static org.assertj.core.api.Assertions.*;

/**
 * C2C MVP 성능 E2E 테스트
 * 
 * 성능 및 부하 테스트:
 * - 동시 접속자 처리
 * - 메시지 처리 성능
 * - 메모리 사용량
 * - 응답 시간
 */
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@ActiveProfiles("test")
@Testcontainers
@DisplayName("C2C MVP 성능 E2E 테스트")
class PerformanceE2ETest {
    
    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:16-alpine")
            .withDatabaseName("c2c_perf_test")
            .withUsername("test")
            .withPassword("test");
    
    @Container
    static GenericContainer<?> redis = new GenericContainer<>(DockerImageName.parse("redis:7.2-alpine"))
            .withExposedPorts(6379)
            .withCommand("redis-server --maxmemory 512m --maxmemory-policy allkeys-lru");
    
    @LocalServerPort
    private int port;
    
    @Autowired
    private RoomRepository roomRepository;
    
    @Autowired
    private UserRepository userRepository;
    
    private ObjectMapper objectMapper;
    private URI serverUri;
    
    @BeforeEach
    void setUp() {
        objectMapper = new ObjectMapper();
        serverUri = URI.create("ws://localhost:" + port + "/ws");
    }
    
    @Test
    @DisplayName("성능: 동시 접속자 100명 처리")
    void shouldHandle100ConcurrentUsers() throws Exception {
        // Given
        int userCount = 100;
        String roomId = "perf-room-100";
        
        CountDownLatch allConnectedLatch = new CountDownLatch(userCount);
        CountDownLatch allJoinedLatch = new CountDownLatch(userCount);
        
        AtomicInteger connectedUsers = new AtomicInteger(0);
        AtomicInteger joinedUsers = new AtomicInteger(0);
        List<WebSocketConnectionManager> managers = new ArrayList<>();
        
        long startTime = System.currentTimeMillis();
        
        // When - 100명 동시 연결
        for (int i = 0; i < userCount; i++) {\n            final String userId = \"user\" + i;\n            \n            WebSocketHandler handler = new WebSocketHandler() {\n                private boolean connected = false;\n                private boolean joined = false;\n                \n                @Override\n                public void afterConnectionEstablished(WebSocketSession session) throws Exception {\n                    if (!connected) {\n                        connected = true;\n                        connectedUsers.incrementAndGet();\n                        allConnectedLatch.countDown();\n                        \n                        // 방 입장\n                        sendJoinMessage(session, userId, roomId);\n                    }\n                }\n                \n                @Override\n                public void handleMessage(WebSocketSession session, WebSocketMessage<?> message) throws Exception {\n                    JsonNode json = objectMapper.readTree(message.getPayload().toString());\n                    String type = json.get(\"type\").asText();\n                    \n                    if (\"joined\".equals(type) && !joined) {\n                        joined = true;\n                        joinedUsers.incrementAndGet();\n                        allJoinedLatch.countDown();\n                    }\n                }\n                \n                @Override\n                public void handleTransportError(WebSocketSession session, Throwable exception) {\n                    System.err.println(\"Transport error for \" + userId + \": \" + exception.getMessage());\n                }\n                \n                @Override\n                public void afterConnectionClosed(WebSocketSession session, CloseStatus status) {\n                    // Connection closed\n                }\n            };\n            \n            WebSocketConnectionManager manager = new WebSocketConnectionManager(\n                new StandardWebSocketClient(), handler, serverUri.toString()\n            );\n            managers.add(manager);\n            manager.start();\n            \n            // 연결 간격 (부하 분산)\n            if (i % 10 == 9) {\n                Thread.sleep(50);\n            }\n        }\n        \n        // Then - 모든 사용자 연결 성공\n        boolean allConnected = allConnectedLatch.await(30, TimeUnit.SECONDS);\n        assertThat(allConnected).as(\"All users should connect within 30 seconds\").isTrue();\n        assertThat(connectedUsers.get()).isEqualTo(userCount);\n        \n        // 모든 사용자 방 입장 성공\n        boolean allJoined = allJoinedLatch.await(30, TimeUnit.SECONDS);\n        assertThat(allJoined).as(\"All users should join room within 30 seconds\").isTrue();\n        assertThat(joinedUsers.get()).isEqualTo(userCount);\n        \n        long endTime = System.currentTimeMillis();\n        long totalTime = endTime - startTime;\n        \n        System.out.println(String.format(\n            \"성능 결과: %d명 동시 접속 완료 시간: %dms (평균 %dms/user)\", \n            userCount, totalTime, totalTime / userCount\n        ));\n        \n        // 성능 기준: 30초 이내 모든 연결 완료\n        assertThat(totalTime).as(\"Total connection time should be under 30 seconds\").isLessThan(30000);\n        \n        // 방 상태 검증\n        List<String> roomMembers = roomRepository.getMembers(roomId);\n        assertThat(roomMembers).hasSize(userCount);\n        \n        // Cleanup\n        for (WebSocketConnectionManager manager : managers) {\n            manager.stop();\n        }\n    }\n    \n    @Test\n    @DisplayName(\"성능: 초당 1000개 메시지 처리\")\n    void shouldProcess1000MessagesPerSecond() throws Exception {\n        // Given\n        String roomId = \"perf-msg-room\";\n        String userId = \"perf-user\";\n        int messageCount = 1000;\n        \n        CountDownLatch connectedLatch = new CountDownLatch(1);\n        CountDownLatch joinedLatch = new CountDownLatch(1);\n        CountDownLatch messagesLatch = new CountDownLatch(messageCount);\n        \n        AtomicInteger sentMessages = new AtomicInteger(0);\n        AtomicInteger receivedMessages = new AtomicInteger(0);\n        AtomicLong firstMessageTime = new AtomicLong(0);\n        AtomicLong lastMessageTime = new AtomicLong(0);\n        \n        WebSocketHandler handler = new WebSocketHandler() {\n            private boolean connected = false;\n            private boolean joined = false;\n            private boolean messagesSent = false;\n            \n            @Override\n            public void afterConnectionEstablished(WebSocketSession session) throws Exception {\n                if (!connected) {\n                    connected = true;\n                    connectedLatch.countDown();\n                    sendJoinMessage(session, userId, roomId);\n                }\n            }\n            \n            @Override\n            public void handleMessage(WebSocketSession session, WebSocketMessage<?> message) throws Exception {\n                JsonNode json = objectMapper.readTree(message.getPayload().toString());\n                String type = json.get(\"type\").asText();\n                \n                if (\"joined\".equals(type) && !joined) {\n                    joined = true;\n                    joinedLatch.countDown();\n                    \n                    // 대량 메시지 전송 시작\n                    if (!messagesSent) {\n                        messagesSent = true;\n                        sendBulkMessages(session, userId, roomId, messageCount);\n                    }\n                } else if (\"message\".equals(type)) {\n                    long currentTime = System.currentTimeMillis();\n                    int received = receivedMessages.incrementAndGet();\n                    \n                    if (received == 1) {\n                        firstMessageTime.set(currentTime);\n                    }\n                    lastMessageTime.set(currentTime);\n                    \n                    messagesLatch.countDown();\n                }\n            }\n            \n            @Override\n            public void handleTransportError(WebSocketSession session, Throwable exception) {\n                System.err.println(\"Transport error: \" + exception.getMessage());\n            }\n            \n            @Override\n            public void afterConnectionClosed(WebSocketSession session, CloseStatus status) {\n                // Connection closed\n            }\n        };\n        \n        // When\n        WebSocketConnectionManager manager = new WebSocketConnectionManager(\n            new StandardWebSocketClient(), handler, serverUri.toString()\n        );\n        manager.start();\n        \n        assertTrue(connectedLatch.await(5, TimeUnit.SECONDS));\n        assertTrue(joinedLatch.await(5, TimeUnit.SECONDS));\n        \n        // Then - 모든 메시지 처리 완료\n        boolean allProcessed = messagesLatch.await(60, TimeUnit.SECONDS);\n        assertThat(allProcessed).as(\"All messages should be processed within 60 seconds\").isTrue();\n        \n        long processingTime = lastMessageTime.get() - firstMessageTime.get();\n        double messagesPerSecond = (double) messageCount * 1000 / processingTime;\n        \n        System.out.println(String.format(\n            \"메시지 처리 성능: %d개 메시지, %dms 소요, %.2f msg/sec\", \n            messageCount, processingTime, messagesPerSecond\n        ));\n        \n        // 성능 기준: 초당 500개 이상 처리 (목표의 50%)\n        assertThat(messagesPerSecond).as(\"Should process at least 500 messages per second\").isGreaterThan(500);\n        \n        manager.stop();\n    }\n    \n    @Test\n    @DisplayName(\"성능: 메모리 사용량 모니터링\")\n    void shouldMonitorMemoryUsage() throws Exception {\n        // Given\n        Runtime runtime = Runtime.getRuntime();\n        long initialMemory = runtime.totalMemory() - runtime.freeMemory();\n        \n        String roomId = \"memory-test-room\";\n        int userCount = 50;\n        \n        CountDownLatch allJoinedLatch = new CountDownLatch(userCount);\n        List<WebSocketConnectionManager> managers = new ArrayList<>();\n        \n        // When - 50명 사용자 생성 및 메시지 전송\n        for (int i = 0; i < userCount; i++) {\n            final String userId = \"mem-user\" + i;\n            \n            WebSocketHandler handler = new WebSocketHandler() {\n                private boolean joined = false;\n                \n                @Override\n                public void afterConnectionEstablished(WebSocketSession session) throws Exception {\n                    sendJoinMessage(session, userId, roomId);\n                }\n                \n                @Override\n                public void handleMessage(WebSocketSession session, WebSocketMessage<?> message) throws Exception {\n                    JsonNode json = objectMapper.readTree(message.getPayload().toString());\n                    String type = json.get(\"type\").asText();\n                    \n                    if (\"joined\".equals(type) && !joined) {\n                        joined = true;\n                        allJoinedLatch.countDown();\n                        \n                        // 각 사용자가 10개 메시지 전송\n                        for (int j = 0; j < 10; j++) {\n                            String messageText = \"메시지 \" + j + \" from \" + userId;\n                            sendChatMessage(session, userId, roomId, messageText);\n                            Thread.sleep(10);\n                        }\n                    }\n                }\n                \n                @Override\n                public void handleTransportError(WebSocketSession session, Throwable exception) {\n                    // Error handling\n                }\n                \n                @Override\n                public void afterConnectionClosed(WebSocketSession session, CloseStatus status) {\n                    // Connection closed\n                }\n            };\n            \n            WebSocketConnectionManager manager = new WebSocketConnectionManager(\n                new StandardWebSocketClient(), handler, serverUri.toString()\n            );\n            managers.add(manager);\n            manager.start();\n        }\n        \n        // 모든 사용자 입장 대기\n        assertTrue(allJoinedLatch.await(30, TimeUnit.SECONDS));\n        \n        // 메시지 전송 완료 대기\n        Thread.sleep(5000);\n        \n        // Then - 메모리 사용량 확인\n        runtime.gc(); // 가비지 컬렉션 실행\n        Thread.sleep(1000);\n        \n        long finalMemory = runtime.totalMemory() - runtime.freeMemory();\n        long memoryIncrease = finalMemory - initialMemory;\n        long memoryInMB = memoryIncrease / 1024 / 1024;\n        \n        System.out.println(String.format(\n            \"메모리 사용량: 초기 %dMB, 최종 %dMB, 증가 %dMB\", \n            initialMemory / 1024 / 1024, finalMemory / 1024 / 1024, memoryInMB\n        ));\n        \n        // 성능 기준: 메모리 증가량 500MB 이하\n        assertThat(memoryInMB).as(\"Memory increase should be under 500MB\").isLessThan(500);\n        \n        // Cleanup\n        for (WebSocketConnectionManager manager : managers) {\n            manager.stop();\n        }\n    }\n    \n    @Test\n    @DisplayName(\"성능: 응답 시간 측정\")\n    void shouldMeasureResponseTimes() throws Exception {\n        // Given\n        String roomId = \"response-time-room\";\n        String userId = \"response-user\";\n        int testCount = 100;\n        \n        CountDownLatch connectedLatch = new CountDownLatch(1);\n        CountDownLatch joinedLatch = new CountDownLatch(1);\n        CountDownLatch responseLatch = new CountDownLatch(testCount);\n        \n        List<Long> responseTimes = new ArrayList<>();\n        AtomicInteger responseCount = new AtomicInteger(0);\n        \n        WebSocketHandler handler = new WebSocketHandler() {\n            private boolean joined = false;\n            private final List<Long> sendTimes = new ArrayList<>();\n            \n            @Override\n            public void afterConnectionEstablished(WebSocketSession session) throws Exception {\n                connectedLatch.countDown();\n                sendJoinMessage(session, userId, roomId);\n            }\n            \n            @Override\n            public void handleMessage(WebSocketSession session, WebSocketMessage<?> message) throws Exception {\n                JsonNode json = objectMapper.readTree(message.getPayload().toString());\n                String type = json.get(\"type\").asText();\n                \n                if (\"joined\".equals(type) && !joined) {\n                    joined = true;\n                    joinedLatch.countDown();\n                    \n                    // 응답 시간 측정을 위한 메시지 전송\n                    for (int i = 0; i < testCount; i++) {\n                        long sendTime = System.nanoTime();\n                        sendTimes.add(sendTime);\n                        sendChatMessage(session, userId, roomId, \"Response test \" + i);\n                        Thread.sleep(10); // 10ms 간격\n                    }\n                } else if (\"message\".equals(type)) {\n                    long receiveTime = System.nanoTime();\n                    int index = responseCount.getAndIncrement();\n                    \n                    if (index < sendTimes.size()) {\n                        long responseTime = (receiveTime - sendTimes.get(index)) / 1_000_000; // ms 변환\n                        synchronized (responseTimes) {\n                            responseTimes.add(responseTime);\n                        }\n                        responseLatch.countDown();\n                    }\n                }\n            }\n            \n            @Override\n            public void handleTransportError(WebSocketSession session, Throwable exception) {\n                System.err.println(\"Transport error: \" + exception.getMessage());\n            }\n            \n            @Override\n            public void afterConnectionClosed(WebSocketSession session, CloseStatus status) {\n                // Connection closed\n            }\n        };\n        \n        // When\n        WebSocketConnectionManager manager = new WebSocketConnectionManager(\n            new StandardWebSocketClient(), handler, serverUri.toString()\n        );\n        manager.start();\n        \n        assertTrue(connectedLatch.await(5, TimeUnit.SECONDS));\n        assertTrue(joinedLatch.await(5, TimeUnit.SECONDS));\n        assertTrue(responseLatch.await(60, TimeUnit.SECONDS));\n        \n        // Then - 응답 시간 분석\n        synchronized (responseTimes) {\n            assertThat(responseTimes).hasSize(testCount);\n            \n            double avgResponseTime = responseTimes.stream().mapToLong(Long::longValue).average().orElse(0.0);\n            long maxResponseTime = responseTimes.stream().mapToLong(Long::longValue).max().orElse(0);\n            long minResponseTime = responseTimes.stream().mapToLong(Long::longValue).min().orElse(0);\n            \n            System.out.println(String.format(\n                \"응답 시간 통계: 평균 %.2fms, 최대 %dms, 최소 %dms\", \n                avgResponseTime, maxResponseTime, minResponseTime\n            ));\n            \n            // 성능 기준: 평균 응답 시간 100ms 이하\n            assertThat(avgResponseTime).as(\"Average response time should be under 100ms\").isLessThan(100.0);\n            \n            // 99% 응답 시간 200ms 이하\n            responseTimes.sort(Long::compareTo);\n            int p99Index = (int) (responseTimes.size() * 0.99);\n            long p99ResponseTime = responseTimes.get(p99Index);\n            \n            System.out.println(String.format(\"99%% 응답 시간: %dms\", p99ResponseTime));\n            assertThat(p99ResponseTime).as(\"99%% response time should be under 200ms\").isLessThan(200);\n        }\n        \n        manager.stop();\n    }\n    \n    // Helper Methods\n    private void sendJoinMessage(WebSocketSession session, String userId, String roomId) throws Exception {\n        String message = String.format(\n            \"{\\\"type\\\":\\\"join\\\",\\\"userId\\\":\\\"%s\\\",\\\"roomId\\\":\\\"%s\\\"}\", \n            userId, roomId\n        );\n        session.sendMessage(new TextMessage(message));\n    }\n    \n    private void sendChatMessage(WebSocketSession session, String userId, String roomId, String text) throws Exception {\n        String message = String.format(\n            \"{\\\"type\\\":\\\"message\\\",\\\"userId\\\":\\\"%s\\\",\\\"roomId\\\":\\\"%s\\\",\\\"text\\\":\\\"%s\\\"}\", \n            userId, roomId, text.replace(\"\\\"\", \"\\\\\\\"\")\n        );\n        session.sendMessage(new TextMessage(message));\n    }\n    \n    private void sendBulkMessages(WebSocketSession session, String userId, String roomId, int count) {\n        Thread thread = new Thread(() -> {\n            try {\n                for (int i = 0; i < count; i++) {\n                    sendChatMessage(session, userId, roomId, \"Bulk message \" + i);\n                    \n                    // Rate limiting 회피를 위한 지연\n                    if (i % 5 == 4) {\n                        Thread.sleep(1000); // 1초 대기\n                    }\n                }\n            } catch (Exception e) {\n                System.err.println(\"Error sending bulk messages: \" + e.getMessage());\n            }\n        });\n        thread.start();\n    }\n}